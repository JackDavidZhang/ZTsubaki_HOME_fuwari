---
title: 从源码开始引导一个简易Linux系统
published: 2025-08-11
description: 通过一个小实验深入理解Linux的启动过程
tags: [OS, Linux]
category: 技术
draft: false
---

## 1. 理论

当我们接通计算机的电源，`BIOS`/`UEFI`在完成自检后会根据预先设定读取硬盘上的`MBR`/`ESP`分区内的记录，启动`bootloader`，如`Windows`下的`BOOTMGR`和`Linux`下常用的`grub`。对于`Linux`，`bootloader`会将`kernel`加载到内存中，然后将系统交给`kernel`，然而此时的内存中只剩下一个`kernel`的二进制代码，没有任何别的数据，没有文件系统也没有用户态的程序，从`kernel`到`shell`之间。`Linux`还需要一个初始化的过程。

### 过程分析

#### 1. 内核空间

`/proc/cmdline`中保存了`bootloader`调用`kernel`时传递的参数
```bash
cat /proc/cmdline
BOOT_IMAGE=/vmlinuz-linux root=UUID=a9c82f40-f0ff-4af3-b630-ddc3d0d0f781 rw loglevel=3 quiet
```
从中可见，我们真正在启动时加载的kernel位于`/vmlinuz-linux`，即`/boot/vmlinuz-linux`，查看该文件得
```bash
file /boot/vmlinuz-linux
/boot/vmlinuz-linux: Linux kernel x86 boot executable, bzImage, version 6.15.9-arch1-1 (linux@archlinux) #1 SMP PREEMPT_DYNAMIC Sat, 02 Aug 2025 01:20:06 +0000, RO-rootFS, Normal VGA, setup size 512*39, syssize 0xf1020, jump 0x26c 0x8cd88ec0fc8cd239 instruction, protocol 2.15, from protected-mode code at offset 0x2cc 0xed7b91 bytes ZST compressed, relocatable, handover offset 0xf012a0, legacy 64-bit entry point, can be above 4G, 32-bit EFI handoff entry point, 64-bit EFI handoff entry point, EFI kexec boot support, xloadflags bit 5, max cmdline size 2047, init_size 0x425b000
ls -lh /boot/vmlinuz-linux
-rwxr-xr-x   1 root root 15.1M Aug  3 21:44 /boot/vmlinuz-linux
```

这是一个内核`6.15.9`的镜像，大小仅`15.1MB`，里面仅仅包含最基本的`kernel`，没有任何用户态的程序，也缺少复杂的驱动程序，理论上来说，`kernel`在加载完成后可以直接根据启动参数指定的设备挂载硬盘上的`rootfs`，但是，此时并没有`rootfs`，更没有`devfs`，其指定的设备仅仅是一个编号，在`kernel`源码中有对应，而不是真实的设备树设备，而且也不能支持通用驱动不能覆盖的各种复杂设备，复杂文件系统，故此时需要一个过渡。

#### 2. 早期用户空间

查看`grub`的配置可以发现

```
menuentry 'Arch Linux, with Linux linux' --class arch --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-linux-advanced-a9c82f40-f0ff-4af3-b630-ddc3d0d0f781' {
		load_video
		set gfxpayload=keep
		insmod gzio
		insmod part_gpt
		insmod fat
		search --no-floppy --fs-uuid --set=root BCB9-E525
		echo	'Loading Linux linux ...'
		linux	/vmlinuz-linux root=UUID=a9c82f40-f0ff-4af3-b630-ddc3d0d0f781 rw  loglevel=3 quiet
		echo	'Loading initial ramdisk ...'
		initrd	/amd-ucode.img /initramfs-linux.img
	}
```

除了启动内核用的`linux`指令外，还有一个`initrd`指令值得注意

为了解决上述问题，我们引入了一个`initrd(Initial RAM Disk)`，由`bootloader`（也可以是`kernel`）在启动前加载入内存中，里面包含了一个完整的`ext2`文件系统，内含基础的运行环境（通常是`busybox`或`systemd`），`kernel`将其临时挂载为`rootfs`，查找并启动初始化程序`/linuxrc`，这就是`PID=1`的**第一个用户态进程**，操作系统从此进入用户态

当然，启动一个完整的文件系统还是会增加`kernel`的复杂度，于是`linux 2.6`引入了`initramfs(Initial RAM File System)`，其实体是一个`cpio`格式的压缩包，而不是一个完整的文件系统，在启动时`kernel`会将其放到一个与`/run`等一样的`ramfs(tmpfs)`中，并将其挂载为`rootfs`，然后启动`/init`或`/sbin/init`进入用户态

一些简单的嵌入式系统也会直接在这个临时的`rootfs`上运行

所以，`/amd-ucode.img`和`/initramfs-linux-img`就是我们的`initramfs`，前者仅包含`AMD`的微码驱动，我们对后者进行解压

```bash
lsinitcpio -x /boot/initramfs-linux.img
```

得到

```bash
ls -lh
-rw-r--r--   1 ztsubaki ztsubaki 4B    Aug 11 19:17 VERSION
lrwxrwxrwx   1 ztsubaki ztsubaki 7B    Aug 11 19:17 bin -> usr/bin
-rw-r--r--   1 ztsubaki ztsubaki 3.2K  Aug 11 19:17 buildconfig
-rw-r--r--   1 ztsubaki ztsubaki 89B   Aug 11 19:17 config
drwxr-xr-x   2 ztsubaki ztsubaki 4.0K  Aug 11 19:17 dev
-rw-r--r--   1 ztsubaki ztsubaki 2B    Aug 11 19:17 early_cpio
drwxr-xr-x   3 ztsubaki ztsubaki 4.0K  Aug 11 19:17 etc
drwxr-xr-x   2 ztsubaki ztsubaki 4.0K  Aug 11 19:17 hooks
-rwxr-xr-x   1 ztsubaki ztsubaki 3.2K  Aug 11 19:17 init
-rw-r--r--   1 ztsubaki ztsubaki 15.2K Aug 11 19:17 init_functions
drwxr-xr-x   3 ztsubaki ztsubaki 4.0K  Aug 11 19:17 kernel
-rw-r--r--   1 ztsubaki ztsubaki 2.5K  Aug 11 19:17 keymap.bin
-rw-r--r--   1 ztsubaki ztsubaki 0B    Aug 11 19:17 keymap.utf8
lrwxrwxrwx   1 ztsubaki ztsubaki 7B    Aug 11 19:17 lib -> usr/lib
lrwxrwxrwx   1 ztsubaki ztsubaki 7B    Aug 11 19:17 lib64 -> usr/lib
drwxr-xr-x   2 ztsubaki ztsubaki 4.0K  Aug 11 19:17 new_root
drwxr-xr-x   2 ztsubaki ztsubaki 4.0K  Aug 11 19:17 proc
drwxr-xr-x   2 ztsubaki ztsubaki 4.0K  Aug 11 19:17 run
lrwxrwxrwx   1 ztsubaki ztsubaki 7B    Aug 11 19:17 sbin -> usr/bin
drwxr-xr-x   2 ztsubaki ztsubaki 4.0K  Aug 11 19:17 sys
drwxr-xr-x   2 ztsubaki ztsubaki 4.0K  Aug 11 19:17 tmp
drwxr-xr-x   5 ztsubaki ztsubaki 4.0K  Aug 11 19:17 usr
drwxr-xr-x   2 ztsubaki ztsubaki 4.0K  Aug 11 19:17 var
```

这是一个完整的`rootfs`结构

```bash
./bin/busybox
BusyBox v1.36.1 () multi-call binary.
BusyBox is copyrighted by many authors between 1998-2015.
Licensed under GPLv2. See source distribution for detailed
copyright notices.

Usage: busybox [function [arguments]...]
   or: busybox --list[-full]
   or: busybox --show SCRIPT
   or: busybox --install [-s] [DIR]
   or: function [arguments]...

	BusyBox is a multi-call binary that combines many common Unix
	utilities into a single executable.  Most people will create a
	link to busybox for each function they wish to use and BusyBox
	will act like whatever it was invoked as.

Currently defined functions:
	[, arch, ascii, ash, awk, base32, base64, basename, bc, blkdiscard, bzip2, cat, chgrp, chmod, chown, chroot,
	clear, cp, cpio, crc32, cttyhack, cut, dd, df, dirname, dmesg, du, echo, env, expr, fallocate, false, fatattr,
	free, fsfreeze, fstrim, fsync, getopt, grep, gzip, halt, head, hexdump, hexedit, i2ctransfer, ifconfig, init,
	install, ip, ipaddr, iplink, ipneigh, iproute, iprule, iptunnel, kbd_mode, kill, killall, less, link, ln,
	loadfont, loadkmap, losetup, ls, lsscsi, lzop, md5sum, mim, mkdir, mkfifo, mknod, mkpasswd, mktemp, mountpoint,
	mv, nc, netstat, nologin, nproc, nsenter, nslookup, nuke, openvt, partprobe, paste, pgrep, pidof, ping, ping6,
	poweroff, printf, ps, pwd, readlink, realpath, reboot, resume, rm, rmdir, route, run-init, sed, seedrng, seq,
	setfattr, setfont, sh, sha1sum, sha256sum, sha512sum, shuf, sleep, sort, stat, strings, sync, tac, tail, tar,
	tcpsvd, tee, telnet, test, tftp, touch, tree, true, truncate, ts, tsort, udhcpc, udhcpc6, umount, uname, uniq,
	unlink, unshare, unzip, uptime, vi, wc, wget, which, xxd, xz, yes
```

由`busybox`提供基本运行环境

我们观察`init`脚本

```bash
cat init
#!/usr/bin/ash
# SPDX-License-Identifier: GPL-2.0-only

export PATH='/usr/local/sbin:/usr/local/bin:/usr/bin'

udevd_running=0
mount_handler=default_mount_handler
init=/sbin/init
rd_logmask=0

. /init_functions

mount_setup

# parse the kernel command line
parse_cmdline </proc/cmdline

# setup logging as early as possible
rdlogger_start

disablehooks="$(getarg disablehooks)"
# busybox ash supports string replacements
# shellcheck disable=SC3060
for d in ${disablehooks//,/ }; do
    [ -e "/hooks/$d" ] && chmod 644 "/hooks/$d"
done

# shellcheck disable=SC1091
. /config

# We rely on word splitting
# shellcheck disable=SC2086
run_hookfunctions 'run_earlyhook' 'early hook' $EARLYHOOKS

if [ -n "$earlymodules$MODULES" ]; then
    # busybox ash supports string replacements
    # shellcheck disable=SC3060,SC2086
    modprobe -qab ${earlymodules//,/ } $MODULES
fi

# We rely on word splitting
# shellcheck disable=SC2086
run_hookfunctions 'run_hook' 'hook' $HOOKS

# honor the old behavior of break=y as a synonym for break=premount
break="$(getarg break)"
if [ "${break}" = "y" ] || [ "${break}" = "premount" ]; then
    # shellcheck disable=SC2086
    run_hookfunctions 'run_emergencyhook' 'emergency hook' $EMERGENCYHOOKS
    echo ":: Pre-mount break requested, type 'exit' to resume operation"
    launch_interactive_shell
fi

if rootdev="$(resolve_device "$root")"; then
    # If the tag is supported by util-linux mount, pass it as is.
    # Otherwise, use the resolved device path.
    case "$root" in
        'UUID='* | 'LABEL='* | 'PARTUUID='* | 'PARTLABEL='*) : ;;
        *) root="$rootdev" ;;
    esac
fi
unset rootdev

fsck_root

# Mount root at /new_root
"$mount_handler" /new_root

# We rely on word splitting
# shellcheck disable=SC2086
run_hookfunctions 'run_latehook' 'late hook' $LATEHOOKS

# We rely on word splitting
# shellcheck disable=SC2086
run_hookfunctions 'run_cleanuphook' 'cleanup hook' $CLEANUPHOOKS

if [ "$(stat -c %D /)" = "$(stat -c %D /new_root)" ]; then
    # Nothing got mounted on /new_root. This is the end, we don't know what to do anymore
    # We fall back into a shell, but the shell has now PID 1
    # This way, manual recovery is still possible.
    # shellcheck disable=SC2086
    run_hookfunctions 'run_emergencyhook' 'emergency hook' $EMERGENCYHOOKS
    err "Failed to mount the real root device."
    echo "Bailing out, you are on your own. Good luck."
    echo
    launch_interactive_shell --exec
elif [ ! -x "/new_root${init}" ]; then
    # Successfully mounted /new_root, but ${init} is missing
    # The same logic as above applies
    # shellcheck disable=SC2086
    run_hookfunctions 'run_emergencyhook' 'emergency hook' $EMERGENCYHOOKS
    err "Root device mounted successfully, but ${init} does not exist."
    echo "Bailing out, you are on your own. Good luck."
    echo
    launch_interactive_shell --exec
fi

if [ "${break}" = "postmount" ]; then
    # shellcheck disable=SC2086
    run_hookfunctions 'run_emergencyhook' 'emergency hook' $EMERGENCYHOOKS
    echo ":: Post-mount break requested, type 'exit' to resume operation"
    launch_interactive_shell
fi

# this should always be the last thing we do before the switch_root.
rdlogger_stop

exec env -i \
    "TERM=$TERM" \
    /usr/bin/switch_root /new_root "$init" "$@"

# vim: set ft=sh ts=4 sw=4 et:
```
可见`init`主要加载了一些在`/etc/mkinitcpio.conf`（`Arch Linux`的`initramfs`由该程序生成）中配置的模块，运行了一些钩子，最关键的，是`mount_setup`函数：
```bash
mount_setup() {
    mount -t proc proc /proc -o nosuid,noexec,nodev
    mount -t sysfs sys /sys -o nosuid,noexec,nodev
    mount -t devtmpfs dev /dev -o mode=0755,nosuid
    mount -t tmpfs run /run -o nosuid,nodev,mode=0755
    mkdir -m755 /run/initramfs

    if [ -e /sys/firmware/efi ]; then
        mount -t efivarfs efivarfs /sys/firmware/efi/efivars -o nosuid,nodev,noexec
    fi

    # Setup /dev symlinks
    if [ -e /proc/kcore ]; then
        ln -sfT /proc/kcore /dev/core
    fi
    ln -sfT /proc/self/fd /dev/fd
    ln -sfT /proc/self/fd/0 /dev/stdin
    ln -sfT /proc/self/fd/1 /dev/stdout
    ln -sfT /proc/self/fd/2 /dev/stderr
}
```
该函数挂载了一些系统运行中产生的特殊目录，而`init`也会处理内核参数并寻找挂载真正的`rootfs`到`/new_root`（对于`systemd`的`initramfs`通常是`/sysroot`），最终通过`switch_root`（`systemd`的`systemd switch-root`）将`/new_root`（`/sysroot`）切换为新的`rootfs`（由于磁盘上不存在前面挂载过的特殊目录，故前面的挂载不会被覆盖，依然有效），然后该进程启动真正的`rootfs`上的`/sbin/init`（通常为`systemd`的符号链接）进入我们所熟悉的晚期用户空间

值得注意的是，我们启动了这么多进程，最终进入晚期用户空间时第一个进程仍然是`PID=1`，这是因为为了标识该进程的独特性，`switch_root`只允许`PID=1`的进程运行，`systemd`也只有`PID=1`运行时才会进行初始化的工作，所以在前面的过程中，`init`启动`switch_root`使用的是`exec`，`switch_root`启动`systemd`用的也是`exec`

#### 3. 晚期用户空间

进入晚期用户空间时我们已经获得了一个完整的`Linux`系统，接下来要做的就简单了，`systemd`根据规则初始化系统服务，然后启动`getty`（或者显示管理器），`getty`会利用`glibc`封装的系统调用接口根据`/etc/shadow`验证我们的密码，然后通过`setuid`实现登录并调用`login`，`login`显示`motd`并启动用户在`/etc/passwd`中指定的`shell`，至此系统成功进入`shell`

## 2. 实操

接下来，我们来从源代码开始，用`qemu`引导一个简易`Linux`系统

### 编译`Linux`

从科大源下载`linux`源码

```bash
git clone --depth=1 https://mirrors.ustc.edu.cn/linux.git
```

配置

```bash
cd linux
make defconfig
scripts/config --disable DEBUG_INFO --enable VIRTIO

```
默认配置关闭`debug`信息，打开`VirtIO`驱动

编译

```bash
make -j `nproc`
```
等待数分钟即可

编译好的内核位于`arch/x86_64/boot/bzImage`

### 编译`busybox`

下载`busybox`源码

```bash
cd ..
wget https://busybox.net/downloads/busybox-1.37.0.tar.bz2
tar -xvf ./busybox-1.37.0.tar.bz2
```

配置
```bash
cd 
make menuconfig
```
由于配置脚本存在`bug`，可能需要手动修改`scripts/kconfig/lxdialog/check-lxdialog.sh`中的`check()`函数，为用于检测的代码中的`main`函数加入`int`返回值

选择`Settings->Build static binary (no shared libs)`

编译

```bash
make -j `nproc`
```
可能需要删除`networking/tc.c`

安装
```bash
make install CONFIG_PREFIX=../initramfs
```

记得设置权限

```bash
sudo chown -R root:root ../initramfs
```

### 制作`initramfs`

编写脚本

```bash
cd ../initramfs
sudo vim init

## 脚本内容如下

#!/bin/sh

mkdir /dev
mkdir /proc
mkdir /sys
mkdir /run

mount -t devtmpfs dev /dev
mount -t proc proc /proc
mount -t sysfs sys /sys
mount -t tmpfs run /run

exec ./linuxrc

## 脚本内容结束
sudo chmod +x ./init
```
脚本挂载了一些特殊目录，然后启动`busybox`的初始化脚本

接着打包`initramfs`

```bash
find . | cpio -H newc -o | gzip > ../initramfs.img
```

### 启动`busybox`

```bash

cd ..
qemu-system-x86_64 -kernel ./linux/arch/x86_64/boot/bzImage\
    -initrd ./initramfs.img\
    -append "console=ttyS0"\
    -enable-kvm -nographic
```

接下来就是启动过程，当出现`Please press Enter to activate this console.`时就代表我们成功进入了`busybox`的系统

> [!TIP]
> 
> `busybox`中使用`poweroff`关机
>

### 进入硬盘系统

到这里还不够，我们只是在内存中的`busybox`中运行，我们最初的目的是希望`initramfs`切换到一般的`rootfs`上

首先，我们需要寻找一套合适的基础组件，可以继续使用`busybox`，这里以`debian`为例

下载`debian`基础组件

```bash
sudo debootstrap --verbose bookworm rootfs https://mirrors.ustc.edu.cn/debian/
```
该步骤会在`rootfs`目录下产生一个`debian`的`rootfs`

记得删除`root`的密码以便登录

```bash
sudo vim roofs/etc/shadow

## 第一行删去*
root::20311:0:99999:7:::
##
```

接下来制作`qemu`的虚拟磁盘，把数据拷进去

```bash
qemu-img create -f qcow2 disk.qcow 10G
sudo qemu-nbd -c /dev/nbd0 ./disk.qcow
sudo fdisk /dev/nbd0

## 在fdsik中
g
n
#一路回车
w
## 退出fdisk

sudo mkfs.ext4 /dev/nbd0p1
sudo mount /dev/nbd0p1 /mnt/tmp
sudo rsync -a rootfs/ /mnt/tmp
sudo umount /dev/nbd0p1
sudo qemu-nbd -d /dev/nbd0
```

再次启动`qemu`

```bash
qemu-system-x86_64 -kernel ./linux/arch/x86_64/boot/bzImage\
    -initrd ./initramfs.img\
    -append "console=ttyS0"\
    -drive file=disk.qcow,format=qcow2\
    -enable-kvm -nographic
```
这次额外挂载了虚拟磁盘

查看`uuid`

```bash
~ # blkid
/dev/sda1: UUID="31333e20-4746-412c-be8e-e478ca16f04b" TYPE="ext4"
```

接下来退出`qemu`，再次编辑`init`

``` bash
#!/bin/sh

mkdir /dev
mkdir /proc
mkdir /sys
mkdir /run

mount -t devtmpfs dev /dev
mount -t proc proc /proc
mount -t sysfs sys /sys
mount -t tmpfs run /run

for arg in $(cat /proc/cmdline)
do
    if [ ${arg:0:10} = 'root=UUID=' ]
    then
        uuid=${arg:10}
    fi
done

if [ -z $uuid ]
then
	exec ./linuxrc
else
	mkdir /new_root
	mount UUID=$uuid /new_root
	exec switch_root /new_root /sbin/init
fi
```

我们增加了根据`kernel`的启动参数挂载`rootfs`并切换的功能，其中`/sbin/init`就是新`rootfs`下的`init`（此处即`systemd`）

接着，在启动参数添加上`uuid`并运行`qemu`

```bash
qemu-system-x86_64 -kernel ./linux/arch/x86_64/boot/bzImage\
    -initrd ./initramfs.img\
    -append "console=ttyS0 root=UUID=31333e20-4746-412c-be8e-e478ca16f04b"\
    -drive file=disk.qcow,format=qcow2\
    -enable-kvm -nographic\
    -m 4096 -smp 2
```

为了流畅运行`debain`，我们还添加了一些参数

观察日志可以发现，在前面应该启动`busybox`的地方，我们的脚本直接运行了`switch_root`，然后就进入了`systemd`启动系统的过程，最终进入了`debian`系统（`hostname`会继承自本机）

直接登录`root`即可进入系统


