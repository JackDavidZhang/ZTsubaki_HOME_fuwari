---
title: C++基础其一：基础元素
published: 2025-02-05
description: 2025年春，C++复习笔记，参考C++ Primer Plus第6版
tags: [C/C++, 编程语言, 笔记]
category: 技术
draft: false
---

## 1. C++简介

### 1.1. C++简史

- 20世纪70年代，贝尔实验室的Dennins Ritchie为了开发`UNIX`系统而开发了`C`语言
- 20世纪80年代，贝尔实验室的Bjarne Stroustrup为了使`C`语言更易用，在`C`语言的基础上引入了对面向对象编程和泛型编程的支持，发明了`C++`
- 20世纪90年代，ANSI与ISO联合制定了`C++`的第一个标准`ISO/IEC 14882:1998`，并获得了ISO, IEC和ANSI批准，称为`C++98`，在最初的`C++`基础上还加入了`STL`、运行阶段类型识别、模板和异常
- 2003年，`ISO/IEC 14882:2003`发布，主要对上一版进行修订，没有改变语言特性，故常用`C++98`表示`C++98/C++2003`
- 2011年，`ISO/IEC 14882:2011`发布，增加了一些特性，称为`C++11`，也是目前比较常用的版本
- 此后陆续发布的版本有`C++14`、`C++17`、`C++20`、`C++23`、`C++26`

### 1.2. C++的特点

- 编译式

- 结构化

- 底层系统接口

- 面向对象

- 泛型编程

### 1.3. C++的编译器

 `C++`本身只是一个标准，不同硬件平台可以提供自己的编译器以便编译出可以在自己平台上运行的程序，一些组织也开发了比较通用的`C++`编译器，如`g++`，`Clang`，`MSVC`等。

`(类)Unix`平台通常使用`g++`，`Windows`平台下可通过安装`Microsoft Visual Studio`使用`MSVC`，或者使用针对`Windows`平台构建的`GUN`软件包（如`MinGW`）中的`g++`。

### 1.4. g++编译C++程序的流程

```mermaid
graph TB
A(源代码 *.cpp/*.cxx)
B[预处理器]
A-->B
C[编译器]
B-->C
D(汇编代码 *.s)
C-->D
E[汇编器]
D-->E
F(目标代码 *.o)
E-->F
G(启动代码)
H(库代码)
I[连接器]
H-->I
F-->I
G-->I
J(可执行程序)
I-->J
K(包含文件 *.h/*.hpp)
K-->B
```

![](1.png)

### 1.5. g++编译器使用

`Linux`直接使用包管理器安装`gcc`和`g++`

`Windows`安装`MinGW`软件包，常用`MinGW-W64`，可直接从`GitHub`下载预构建版本，安装完成后手动将安装目录下的`bin`目录添加到系统`path`环境变量中。

::github{repo="niXman/mingw-builds-binaries"}

- 基本应用

  ```bash
  g++ t.cpp
  ```

  默认输出`a.out`

  `g++`默认通过扩展名判断编程语言，需要注意源文件拓展名

- 更改输出文件名

  ```bash
  g++ -o t t.cpp
  ```

- 多个输入

  ```bash
  g++ -o t t1.cpp t2.cpp t1.h t2.h t3.o
  ```

  注意，输出为可执行程序时，所有输入（包括目标文件）中必须包含且只包含一个`main`函数

- 只预处理文件

  ```bash
  g++ -E t.cpp
  ```

  直接输出到标准输出，需要保存的请手动重定向

- 只编译代码，不进行汇编

  ```bash
  g++ -S t.cpp
  ```

  输出汇编代码到`*.s`

- 输出目标代码，暂不连接

	```bash
	g++ -c t.cpp
	```

	输出目标代码`*.o`

	目标代码可以在编译时直接作为输入使用，见“多个输入”的示例

	大型工程往往在编译时分出很多目标代码，当某个模块更改时，只用重新编译对应的目标文件，然后重新链接一次，可以大大减少编译时长

- 包含库

  ```bash
  g++ -o t t.cpp -llibrary
  ```

  额外包含库，`l`后面直接加库名称，无空格

  ```bash
  g++ -o t t.cpp -Ldir
  ```

  额外包含库搜索目录，`L`后面直接加目录名称，无空格

- 调试选项

  ```bash
  g++ -o t -g t.cpp
  ```

  输出包含调试信息的程序，调试信息包含变量名，源代码等，使用`gdb`调试器时必须开启该选项

  

- 编译优化

  ```bash
  g++ -o t t.cpp -Ox
  ```

  `x`可选`0,1,2,3`，`0`表示关闭编译优化，`1`为默认等级，`3`为最高等级

  在调试时常关闭优化以保证生成的程序与源文件相同，生成发布版本时开启最高等级以保证运行速度

- 警告输出

  ```bash
  g++ -o t t.cpp -Wall
  ```

  输出所有警告

  ```bash
  g++ -o t t.cpp -Werr
  ```

  把警告视为错误，遇到警告会终止编译

  ```bash
  g++ -o t t.cpp -w
  ```

  忽略所有警告，在编译大型项目时用来快速定位错误

- 动态库选项

  ```bash
  g++ -o t t.cpp -static
  ```

  禁止使用动态库，编译后的程序比较大，但不需要动态库就可以运行

  ```bash
  g++ -o t t.cpp -share
  ```

  尽可能使用动态库，编译后的程序较小，且需要系统的动态库才可以运行

- 语言标准

  ```bash
  g++ -o t t.cpp -std=c++17
  ```

## 2. 关键字与标识符

### 2.1. 关键字

关键字是计算机语言中的词汇，这些词有特殊的意义，不能用作他用。

各标准中出现的`C++`关键字如下

| C++98               |               |                 |           |                  |           |            |          |
| ------------------- | ------------- | --------------- | --------- | ---------------- | --------- | ---------- | -------- |
| and                 | and_eq        | asm             | auto      | bitand           | bitor     | bool       | break    |
| case                | catch         | char            | class     | compl            | const     | const_cast | continue |
| default             | delete        | do              | double    | dynamic_cast     | else      | enum       | explicit |
| export              | extern        | false           | float     | for              | friend    | goto       | if       |
| inline              | int           | long            | mutable   | namespace        | new       | not        | not_eq   |
| private             | protected     | public          | register  | reinterpret_cast | return    | short      | signed   |
| sizeof              | static        | static_cast     | struct    | switch           | template  | this       | throw    |
| true                | try           | typedef         | typeid    | typename         | union     | unsigned   | using    |
| virtual             | void          | volatile        | wchat_t   | while            | xor       | xor_eq     |          |

| C++11               |               |                 |           |                  |           |            |          |
| ------------------- | ------------- | --------------- | --------- | ---------------- | --------- | ---------- | -------- |
| alignas             | alignof       | char16_t        | char32_t  | constexpr        | decltype  | noexcept   | nullptr  |
| static_assert       | thread_local  |                 |           |                  |           |            |          |

| C++20               |               |                 |           |                  |           |            |          |
| ------------------- | ------------- | --------------- | --------- | ---------------- | --------- | ---------- | -------- |
| char8_t             | concept       | consteval       | constinit | co_await         | co_return | co_yield   | requires |

| C++26               |               |                 |           |                  |           |            |          |
| ------------------- | ------------- | --------------- | --------- | ---------------- | --------- | ---------- | -------- |
| contract_assert     |               |                 |           |                  |           |            |          |

| TM TS/reflection TS |               |                 |           |                  |           |            |          |
| ------------------- | ------------- | --------------- | --------- | ---------------- | --------- | ---------- | -------- |
| atomic_cancel       | atomic_commit | atomic_noexcept | reflexpr  | synchronized     |           |            |          |

:::note

`TM TS`和`reflection TS`是非`ISO C++`的`C++`标准，各编译器支持程度不同

:::

### 2.2. 标识符

标识符是用来标记变量，函数名等的符号，通俗讲就是各种“名字”

符合以下规则的是`C++`中的合法标识符

- 只包含大写字母、小写字母（区分大小写）、数字和下划线
- 不能以下划线开头
- 不能是`C++`的关键字
- 理论上没有长度限制，但不同编译器可能会存在长度限制

:::note

由下划线开头的标识符往往是系统使用的，不建议使用下划线开头的标识符

:::

虽然满足上述要求就是合法的标识符，但是不同标识符往往会遵守一些约定俗成的编码规范/命名方案以便于阅读。

## 3. 基本数据类型

### 3.1. 整型

- `char`：1字节
- `short`：至少16位，通常是16位
- `int`：至少与`short`一样长，通常是32位
- `long`：至少32位，且至少与`int`一样长，通常是32位
- `long long`：至少64位，且至少与`long`一样长，通常是64位

:::note

计算机中有符号数常采用补码表示法

正数首位为0，负数首位为1，对于$N$位的补码$-a(0 < a < 2^{N-1})$，其原码表示的数字就是$2^N-a$，这样以来，我们可以轻松处理在0附近从正数减到负数时的退位溢出问题而不用额外考虑复杂的符号变换，同时正数也能兼容无符号数

另一方面，符号不同的补码也可以直接相加，即$a+(-b)=a+(2^N-b)=a-b$，计算机内部计算减法时也可以直接将其转化成负数然后计算，非常易用

当对补码取相反数时，只需将原码按位取反再加1即可

这样一来，原数字变成相反数的过程中，低位的0全部变成1，加上1后一直进位，直到遇见1（取反后是0），那么互为相反数的补码就只有最低位到第一个1的位置是一样的，高位都互为相反数，我们把这个相同的数字叫`lowbits`，即`lowbits=a&(-a)`，数学上是该数字最大的2的幂因子，这个技巧在一些算法中非常有用

根据上面分析不难看出，$N$位补码可表示的范围就是$-2^{N-1} \sim 2^{N-1}-1$，$2^{N-1}-1$上溢后会变成$-2^{N-1}$，反之$-2^{N-1}$下溢就是$2^{N-1}-1$

:::

:::tip

`char`是用来存储字符的数据类型，但也常会被用作存储较小的数字

`char`用来存储`ASCII`字符时，其数字就是字符对应的`ASCII`编码

当`char`用来存储`Uincode`字符时，负数表示该字节与后面的字节构成完整字符，该字节没有达到字符编码的末尾

存储`Unicode`字符还会使用`wchar_t`（一般为`short`，因编译器而异）和`C++11`新增的`char16_t`和`char32_t`

:::

### 3.2. 无符号整型

在上面的有符号整型前加上`unsigned`即为对应的无符号类型

$N$位无符号数的范围即为$0\sim 2^N-1$

实际上，`unsigned`是`unsigned int`的简写，同理，`signed`也是`signed int`的简称，而`short`，`int`，`long`，`long long`实际上是`signed short`，`signed int`，`signed long`，`signed long long`的简写

#### 整型书写方法

- 十进制数：直接书写，无前导0
- 八进制数：含前导0
- 十六进制数：含前导0x

- 不带任何后缀的数字会被存储为`int`，超过`int`范围的会被依次存储为`long`，`long long`
- 带后缀`l/L`，`ll/LL`会分别被存储为`long`，`long long`
- 带后缀`u/U`，`ul/UL`，`ull/ULL`会分别被存储为`unsigned int`，`unsigned long`，`unsigned long long`

### 3.3. 浮点数

- `float`：至少32位，通常是32位
- `double`：至少是48位，通常是64位
- `long double`：至少和`double`一样长，通常是128位

:::note

计算机中的小数通常采用浮点表示法，故称为浮点数，数据分为符号位、有效数和指数，浮点数的实际值表示为$(-1)^{符号位}\times 有效数\times 2^{指数}$，指数按照偏移量的方式处理负数，不同长度的浮点数有不同的分配方式，详见[IEEE 754](https://standards.ieee.org/ieee/754/6210/)标准

:::

#### 浮点数表示法



## 4. 语句

## 5. 流程控制

## 6. 运算符

