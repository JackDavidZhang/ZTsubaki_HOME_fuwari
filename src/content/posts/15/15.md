---
title: C++基础五：数组、指针与动态内存分配
published: 2025-03-08
description: 2025年春，C++复习笔记
tags: [C&C++, 笔记]
category: 技术
draft: false
---

## 1. 数组

数组是一些列相同类型变量排列在一起的数据类型

采用如下格式创建数组

```cpp
type name[n];
```

其中，`type`为数组中元素的类型，`name`为数组名，`n`为数组大小

:::important

这种方法定义的数组是放在栈空间的，C++标准遵循编译时确定所需栈空间大小的原则，故数组大小必须是常量，但是有些编译器也支持使用变量作为数组大小，这种方法会引发很多潜在的安全问题，我们并不推荐使用这种方法

:::

使用时，使用`name[n]`表示数组的第`n`号元素即可

:::important

下标`n`可以是任何正整型变量、数字，从`0`开始，而不是`1`，最大为`n-1`，请格外注意，编译器无法检查下标越界，而运行时过程中下标越界会导致程序崩溃在内的一系列严重后果

:::

由于数组的底层原理（见第2小节），数组之间的相互赋值是不被允许的，即不能直接让一个数组等于另一个数组，但是可以通过循环将数组的每个元素赋值给另一个元素，或者使用`C`语言中的`memcpy`直接复制整块内存

```cpp
memcpy(dest,src,sizeof(src));
```

请注意目标数组至少要比源数组大

:::note

`sizeof`运算符会返回操作对象的大小（以字节为单位），如果是数组则返回整个数组大小，这在尤其是一些`C`语言的库中非常有用

`sizeof`操作的对象可以是类型、变量（非符号常量）等

要注意的是，如果`sizeof`操作的是数组，请确保有足够的上下文能够推断出数组大小，否则编译器会将其解释为对应类型指针的大小

:::

数组可以使用列表初始化（`C++11`新增），语法如下

```cpp
type name[n]={value1,value2,...,valuen};
```

可以省略赋值的等号，甚至省略数组大小，编译器会根据后面的元素个数推断，如果元素个数少于指定的大小，只有前面的部分会被初始化

列表初始化禁止从大到小的类型转换

在初始化了的基础上，我们可以将数组设为`const`（实际应该理解为数组里面存的类型是`const`），这样数组内的值就不能更改了

对于`char`类型组成的数组，即一串字符，我们有另一个名字——字符串

:::tip

`C++`引入了更好用的字符串`string`类，故我们习惯把字符数组称作`C`风格字符串

:::

字符串是以空字符（`ASCII`码为`0`，写作`\0`，不是空格）的字符结尾的，该字符标记字符串的结尾，没有该字符则只是普通的`char`型数组，在使用一些针对`C`风格字符串的函数时会产生下标越界

这样一来，`char`型的数组可以使用双引号包裹的字符串赋值，初始化时同样可以省略大小，编译器会自动推断大小，但是如果手动设置大小，请注意为末尾的`\0`预留一个字节的大小，且非`ASCII`字符可能会使用大于`1`个字节来存储一个字符，初始化后也可以用字符串字面值给`char`数组赋值，如果需要改变字符串的内容，请在创建时分配可能得最大大小，如果用来赋值的字符串大小小于数组大小，剩下的空间都会被填充为`\0`

`char`数组支持任何针对数组的操作，我们也可以用下标提取出它的每一位，用如下方法可以实现对`C`风格字符串的遍历

```cpp
for(int i = 0;str[i];i ++)
{
    //...
    //字符串以'\0'结尾，它对应的值为0，0转换为布尔型对应false，刚好可以用作判断条件
}
```

在函数间传递数组时，我们可以使用`type name[]`表示一个数组，但是这仅仅会传递数组的**地址**，不会复制数组的值，我们对数组的改变会同步到原来的数组（与引用一样），且不包含数组的大小信息，对函数参数使用`sizeof`只会返回地址的长度，需要额外传入参数表示函数长度，同时为了避免以外更改，对无需更改的参数推荐使用`const`限定符

同理，传递返回值时也是这么个规则，这也导致在不使用动态内存分配的情况下我们无法返回一个新的数组，只能在参数传入一个数组供我们写入要返回的内容，这时往往会返回一个`int`值表示写入的数组长度

:::note

无论用什么方式创建数组，其大小在确定后就无法更改，要使用变长的数组需要更复杂的数据结构，常用`STL`中的`vector`

:::

## 2. 指针

前面或多或少提到过“地址”的概念，这样一个“地址”的实体就是指针

指针就是指向一块内存区域的地址，指针是`C`和`C++`提供底层硬件访问的核心，它代表了一块真实存在的内存区域

对变量（左值）使用地址运算符`&`（与引用中的`&`含义完全不同）就可以获得其对应的地址，如果直接输出这个地址，会表现为一个16进制的数字，具体长度取决于目标平台的字长（通常是`64`或`32`位，与`size_t`的大小一样），这个地址的类型就是指针`type*`（这个`*`用法与引用中的`&`相似）

在一个数据类型后面加上`*`，我们就得到了它对应的指针类型，存储一个指向该类型数据的指针，编译器通过指针对应的类型判断指针指向区域的大小

:::tip

指针的数据类型可以通过强制类型转换随便转换，比如将一个`int*`型转换成`long long*`型，这样编译器就会把对应的值强行解释为`long long`，但是这会导致对其后面个4字节的非法访问，可能导致程序崩溃

有时也会把类型设为`(void*)`，这表示一个纯粹的地址，不包含类型（即大小）信息

:::

指针也可以项普通的变量一样声明与赋值分开，用法如下

```cpp
type * name;
name = &target;
```

也可以更改指向的地址，如果需要使用指针指向的内容，则需要使用解引用运算符`*`

类似于`&`，此处的`*`与指针类型中的`*`也不是一样的含义

```cpp
int a = 1;
int * p_a = &a;
std::cout << a;//输出1
std::cout << p_a;//输出一个地址
std::cout << (*p_a);//输出1
```

在不同的系统上，输出的地址不一样，而使用`a`与`*p_a`其实是一样的效果（为避免可能存在的运算符优先级问题，请尽可能使用括号）

如果指针指向一个结构体，要使用结构体的成员，可以解引用后使用，也可以用指针成员运算符`->`，无需解引用，直接对指针使用就可以得到成员，效果与对解引用的变量使用`.`相同

:::warning

指针非常底层，这也意味着指针非常危险，使用指针非常容易产生非法的内存访问，进而导致程序崩溃

首先，为指针赋值的时候一定不能使用数字，只能使用某个左值的地址，否则编译器会将数字视为地址，而地址是操作系统决定的，这样的操作一定会导致程序出现错误，同时，给指针对应的变量赋值时也千万注意不能忘记`*`

不要操作没有初始化的指针，没有立即初始化的指针都应该被设为**空指针**（`nullptr`，`NULL`或`0`）以标志该指针未初始化，使用非确定来源的指针是也务必检查是否是空指针

:::

指针也可以使用`const`，但是`const`需要放在`*`后面，表示指针是常量，而不是指针指向的对象是常量，比如

```cpp
int * a;//指针及指向变量都可变
const int * b;//指针可变，指向的量不可变
int * const c;//指针不可变，指向的量可变
const int * const d;//指针和指向的量都不可变
```

在指针作为函数参数时，我们一般都会将其设为`const`

同样的，指向常量的指针也可以指向变量（但是无法通过该指针改变变量的值），但是指向变量的指针不可以指向常量

## 3. 指针与数组

指针可以进行加减运算（不是对指针指向的值）

前面提到，指针指向的类型代表了指针指向内存区域的大小，那么在指针上进行加减法，实际上就是加上多少块这样的内存区域，或者减少多少块这样的内存区域

以`4`字节的`int`为例，对指向`int`的指针加`1`，实际上就是对它的地址加`4`，相当于指向了紧挨着的下一个`int`值（如果有的话）

:::warning

指针实际上就是一个整型值，所以你也可以对它进行任何整型支持的算术运算，但是通常没有意义

不管是加减还是其它，请务必在确保有意义的情况下对指针进行运算，否则会产生严重后果

:::

像这样，我们就发现了用指针管理一段连续内存的方法

实际上，`C++`中的数组和指针就是等效的

我们声明一个数组`type name[n]`，实际上在栈上分配了`n*sizeof(type)`的内存，然后`name`就是一个指向这块内存开始区域的指针，类型为`type * const`，它们之间是完全等价的，我们可以将数组赋值给这一个指针（当然，它们指向的是同一块区域，不存在值复制），而对数组的访问，实际上就是对指针计算后的访问，`name[i]`与`*(name + i)`是完全等效的，连用法都一样，这也解释了为什么下标从`0`开始，因为下标实际上是相对于第一个元素的偏移量，而`sizeof`无法正确获知函数参数中的数组大小的原因也显而易见了，因为它只是一个指针，根本不含有大小信息

另一方面，既然数组是指针，这个指针需要和下标相加，那么它们的类型一定是（最终转换成）一样的，这又解释了为什么用在数组大小上的`size_t`和地址的数值是同一类型了

我们在书写函数的参数类型时，数组就可以被书写为`type[]`或者`type*`了（对于指针而言，函数传递的是值，传参过程复制了一个地址的值，所以`const`指针也可以传递给非`const`指针，实际上无论如何都会创建一个临时变量）

而指针也可以指向指针，如`int **`就是指向一个`int`指针的指针，这偶尔会被用在需要改变一个外部指针变量的函数中（这一用法与引用效果一样，`C`语言中没有引用，所以有的程序员习惯使用指针而不是引用来实现这一功能，实际上引用比指针安全很多，推荐使用引用）

指针也可以指向数组，使用`type (*name)[n]`创建一个指向数组的指针

:::important

`type (*name)[n]`是指向一个长度为`n`的`type`型数组的**数组指针**，而`type *name[n]`是含有`n`个指向`type`型的指针的**指针数组**，其本质区别是，前者首先是一个指针，其次指向数组，而后者首先是一个数组，其次包含指针

而对于一个数组`type name[n]`，`name`是指向其第一个元素的指针`type*`，而`&name`是指向数组的指针`type(*)[n]`

:::

基于这一原理，我们可以创建一个指向数组的指针，对这个指针进行加减就会跳过一整个数组，对其解引用又是一个普通的数组，这就是二维数组

`type name[n][m]`就表示一个二维数组，其中，`n`和`m`表示该数组第一个维度有`n`个，第二个维度有`m`个，从原理上讲，`name[i][j]`就等于`*(*(name+i)+j)`，也就是说，`name`是一个指向含有`m`个元素的数组的指针`type(*)[m]`，也就是指向第一维的第一个元素（`m`个元素数组），在`name+i`就是指向第`i`个数组的指针，解引用后就是第`i`个数组本身，再加上`j`就是指向第`i`个数组的第`j`个元素的指针

在二维数组中，对指针做算术运算过程需要确切知道数组的大小，因此`type(*)[n]`与`type**`不能简单划等号，后者指向的只是指针，前者指向的是数组，在进行加减法计算时步长并不一样，也因为这样，如果要将二维数组赋值给指针，必须明确其指向数组的大小

:::note

除了数组指针，还有另外一种方法实现二维数组，就是指针数组

```cpp
int a[2]{1,2};
int b[3]{3,4,5};
int *c[2]{a,b};
std::cout << c[0][1];//2
```

这种方法使用了一个指针数组存储其它数组（不是指向数组的指针），相比数组指针的方法，这种方法允许第二个维度的数组存储在离散的内存区域，且第二维度的长度不用对齐，但是需要一个额外的数组存储指针（使用数组指针的常规方法中数据全部在一块，由指针算术进行定位，没有存储多余数据），而且维度超过二维后会非常复杂，不能通用

:::

上述二维数组可以拓展到任意维度，原理相同，不过要注意总大小不要太大

## 4. 函数指针

在冯诺依曼架构中，指令与数据被共同存储在内存中，在现代的操作系统中，一个进程的虚拟内存空间也会被划分成程序段和数据段等，`C`语言允许我们通过函数指针有限的访问程序段

使用如下格式声明一个函数指针

```cpp
return_type (*name)(type1,typr2,...);
```

显然，这里也不能省略`(*name)`的括号，否则就变成函数声明了，括号的含义也和数组指针一样

另一点与数组相似，函数名代表的就是这个函数的地址，也就是说，我们可以直接将（特征匹配的）函数赋值给函数指针

```cpp
name = func;
```

使用函数指针时，也可以直接使用名字，或者进行解引用

```cpp
name(value1,value2,...);
(*name)(value1,value2,...);
```

解引用处的括号依然不能省，否则会被视为对返回值解引用

函数指针也可以和指针数组混用，如

```cpp
return_type (*name[n])(type1,type2,...);
```

就是一个`n`个函数指针组成的数组

使用时

```
name[i](value1,value2,...);
(*name[i])(value1,value2,...);
```

都是一样的

而

```cpp
return_type (*(*name)[n])(type1,type2,...);
```

是指针函数数组指针，使用时要先解引用

```cpp
(*name)[i](value1,value2,...);
```

如果你有什么~~特殊需求~~，你也可以把它弄成多维的数组

最终，我们看一个例子

```cpp
const double *(*(*pd)[3])(const double*,int);
```

这是一个指向包含三个指向返回值为指向`const double`的指针，参数为指向`const double`的指针和`int`的函数的指针的数组的**数组指针**

:::note

鉴于以上内容实在过于复杂，建议在处理此类问题时使用`auto`结合`decltype`推断类型，避免出错，实在不行写一个比较离谱的类型转换，看看编译器报错里的类型也可以

:::

:::tip

无论何时对较大的对象进行传递时，非必要都请使用指针（或引用）以避免值复制，这样即拖慢速度又占空间

:::

## 5. 动态内存分配

前面提到，`C++`栈空间使用的内存在编译时就已经被确定，而有些时候我们必须要分配运行时才知道大小的内存，或者需要很大块内存，栈空间不够放时，我们就要使用动态内存分配

在一个程序的虚拟内存空间中，数据主要存储在堆栈区域，其中，栈是一种先进后出的数据结构，就像一个只有一个口的桶，我们只能从最顶端放东西进去，从最顶端拿东西出来（仅读取的时候不受影响），遵循这种结构，我们可以让数据堆满栈空间，而只要根据偏移量就可以轻松访问这些数据，高速且高效，但是其弊端就是只能存储生命周期随程序运行确定的局部变量，在进入作用域时被压入栈，离开作用域时弹出栈，栈顶就是当前作用域的变量，它们在结束时一同出栈，但是如果有不是当前作用域的变量失效，栈中就会产生一块空出来的空间，当然这个操作也是不被允许的，而堆就是为了存储动态分配的数据出现的，堆上的数据不受作用域的影响，由程序动态分配，操作系统使用特定的算法为数据分配空间，这使得堆的速度较慢，效率也较低，但是可以动态分配

在`C++`中，使用关键字`new`和`delete`实现动态内存分配

`new`接受一个类型，返回对应指针，`delete`则接受一个指针，系统回收它指向的区域

```cpp
int *pi = new int;
delete pi;
int *pa = new int[10];
delete[] pa;
```

需要注意的是，前面也说过，单纯指针不具有分辨到底是数组还是单一个元素的能力，所以`new`分配的数组需要使用`delete[]`以确保回收整一个数组

`new`分配的数组大小可以是变量，在系统内存允许的范围内可以尽可能大（内存不足会抛出异常）

:::warning

使用`new`分配的内存在用完后一定要使用`delete`释放，否则指针离开作用域后程序就会失去对这块内存的控制，但是这块内存依然存在于内存中，不会被回收，导致**内存泄漏**，内存泄漏会浪费很多内存，严重时会导致内存耗尽，任何程序员都有义务避免内存泄漏

:::

`delete`一个空指针是安全的，程序经过判断后不会执行任何操作，所以请将所有需要延迟初始化的指针设为空指针

:::note

在`C`语言中，动态分配内存使用的是`malloc`和`free`两个`stdlib.h`中的库函数

```cpp
int *pi = (int*)malloc(sizeof(int));
free(pi);
int *pa = (int*)malloc(sizeof(int)*n);
free(pa);
```

`malloc`返回的是`void*`类型的指针，故需要进行强制类型转换

请注意，用`new`分配的内存必须用`delete`释放，用`malloc`分配的内存必须用`free`释放，混用会导致严重后果，也不推荐在同一个程序中混用两种内存分配方式

`free`空指针会使程序崩溃，使用前需判断一下

当内存耗尽时，`malloc`可能直接返回空指针，需要进行判断

:::

总而言之，对较小的数据，如单个基本变量，我们没必要使用指针和动态内存分配，而对于比较大的内存，如数组、结构体、类等，这些东西就推荐使用指针和动态内存分配了
