---
title: C++基础六：类与对象
published: 2025-03-10
description: 2025年春，C++复习笔记
tags: [C&C++, 笔记]
category: 技术
draft: true
---

## 1. 面向对象编程

面向对象编程（OOP）是一种相对较新的编程范式

面向对象编程将程序要处理的对象抽象为一个**类**，我们可以将要处理的对象定义为一个类，这个类有自己的属性，称作**成员变量**，也可以有自己的行动，称作**成员方法**，需要使用时，只需要实例化一个**对象**，就像对结构体一样使用这个对象即可

:::note

实际上结构体已经提供了很简单的面向对象特性，后面的类将会提供更多的高级实用的特性

:::

类与对象的设计为我们提供了一些特性：

- 访问控制

  使用类的人并不需要知道类的所有特征，对内部数据意外的更改甚至会导致程序出现意外错误，就像点餐的人并不需要知道餐厅还剩下多少食材，只用知道自己点的能不能做即可，类提供了这种访问控制，我们可以决定类的那些成员是对使用者可见的，哪些是对使用者不可见的

- 继承与多态

  三角形和正方形都属于几何图形这一类，在面向对象方法中，我们可以使三角形和正方形同时继承几何图形类，这样它们就拥有了几何图形的所有成员，而子类仍然可以就自己不同的地方更改父类的成员（如果父类允许的话），在需要使用父类的地方，这个子类有父类所有的成员，故完全可以充当父类

  更甚者，我们可以定义一个抽象的父类，描述原有同一类成员的对象，再要求子类去实现这些成员，比如我们的几何图形类可以有一个“画在纸上”的方法，而具体怎么画就要求三角形或是正方形去实现，我们只要调用这个方法就行，这样一来，借助几何图形类，使用几何图形的人和实现几何图形的人就可以通过这个公有的**接口**完全分离的工作了

:::note

当引入多态的特性后，我们的一个几何图形对象可能是三角形也可能是正方形，在调用成员方法时，就必须通过额外标识标记这个方法到底是哪个子类中的方法，这也只有在运行时才能确定了，无法像传统的`C`语言一样在编译时就确定了

我们把在编译时链接函数调用的过程称为**静态联编**，在运行时过程中链接函数调用的过程称为**动态联编**，动态联编会提供更好的抽象能力，但是必然会损失掉一定的性能

:::

## 2. 类基本操作

我们可以使用如下方式定义一个类

```cpp
class className
{
    private:
    	type name1;
    	type name2;
    	ruturnType func1(type name);
    public:
    	type name3;
    	type name4;
};//别忘了分号
```

这里使用了两个访问控制符：`private`和`public`，顾名思义，`private`就是对外部不可见，只能在自己的成员内使用，`public`就是对外部可见，可以在外部函数中被调用，如果没有指定访问控制符则默认为`private`

类似于结构体，类定义也只是一个定义而非实现，应该被放在头文件中，而里面声明的函数也应该在源文件中被实现（实现一次）

:::note

在实际开发中，我们通常将类单独放到一个同名的头文件中，类的实现放到另一个同名的源文件中，以此方便管理

作为一个例外，`C++`允许在类定义中实现成员函数，但是这样的函数会自动变为内联函数，也可以显式加上`inline`声明内联函数

:::

成员函数在类名称空间中，即实现或调用（静态函数）时要使用`className::func`，成员函数中使用本类的变量时直接使用变量名即可，而如果有需要，（非静态）成员函数中还可以使用一个`this`指针，该指针指向调用该函数的对象自身

类声明后可以被当作普通变量定义和使用，其定义的变量就是这个类的对象，定义对象的过程叫做实例化

对象通过`.`运算符访问（公开的）成员，对象的指针则使用`->`运算符访问

在类中定义的变量，其作用域都是类作用域

## 3. 构造函数与析构函数

也可以为成员变量提供默认值，但`C++`提供了一种更好的方法初始化对象，即**构造函数**

构造函数是与类同名的函数，构造函数没有返回值，在对象创建时会调用该函数，即`Class obj_name = Class(...);`

:::tip

严格来说，构造函数不是没有返回值，只是固定返回对象而被省略了

:::

也可以隐式调用，即`Class obj_name(...);`

当我们没有显式提供构造函数时，编译器会自动生成一个没有参数，也不进行任何操作的默认构造函数，使用默认构造函数可以省略构造函数调用，和普通变量表现一致，即`Class obj_name();`与`Class obj_name;`等效

如果我们显式提供了构造函数，默认构造函数就会失效，如果没有提供没有参数的函数，就无法使用`Class obj_name`，这是为了避免出现忘记初始化的变量，`C++`认为我们既然提供了构造函数，那这个类就是需要初始化的，从而拒绝生成未初始化的默认构造函数，如果确有需求，可以手动编写一个空的构无参造函数使用

而如果我们在构造函数中使用`new`分配了一段内存，那我们就必须在对象被销毁（离开作用域，或是使用`delete`）前释放这些内存，为了实现这一功能，`C++`引入了一个与构造函数相对应的概念——**析构函数**

析构函数是函数定义为`~`加类名的函数，即`~Class()`，析构函数没有参数（留空）也没有返回值，在对象被销毁时编译器会自动调用这个函数，一般会完成一些内存的回收工作

析构函数可以被主动调用，但是一般不建议这么做

所以，一个标准的类应该包含这样的定义

```cpp
class className
{
    private:
    	type name1;
    	type name2;
    	ruturnType func1(type name);
    public:
    	type name3;
    	type name4;
    	className();
    	~className();
};
```

## 4. 
